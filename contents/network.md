# 네트워크

<br />

-----------------------

### HTTP 메소드에 대해서 설명하세요.

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

[ CRUD 관점에서 설명해야함 ]
Create(생성), Read(읽기), Update(갱신), Delete(삭제)

- __POST :__ 서버나 특정 리소스에 엔티티를 제출할 때 사용합니다. Create나 Update, Delete등을 할 때 사용하기도 합니다. [Create]
- __GET__ : 특정 리소스의 참조를 요청합니다. CRUD를 예로 들 경우 R에 해당합니다. url에 어느 리소스를 참조 요청하는지 드러나게 됩니다.[Read]
- __PUT__: PUT를 통해 해당 리소스를 수정합니다. UPDATE를 하지만 전체 자원을 업데이트 하는데 쓰인다고 합니다. [Update]
- __DELETE__ : 삭제 할 때 사용. 어느 자원을 삭제할 지 url에 드러나게 됩니다.[Delete]
- __PATCH__: 리소스의 부분을 수정하는데 사용합니다. 의미론적으로 UPDATE와 더 가깝다고 할 수 있습니다.

HTTP Request Method
GET : 특정 리소스의 참조를 요청합니다. CRUD를 예로 들 경우 R에 해당합니다. url에 어느 리소스를 참조 요청하는지 드러나게 됩니다.
POST: 서버나 특정 리소스에 엔티티를 제출할 때 사용합니다. Create나 Update, Delete등을 할 때 사용하기도 합니다.
PUT: UPDATE를 하지만 전체 자원을 업데이트 하는데 쓰인다고 합니다.
DELETE: 삭제 할 때 사용. 어느 자원을 삭제할 지 url에 드러나게 됩니다.
PATCH: 리소스의 부분을 수정하는데 사용합니다. 의미론적으로 UPDATE와 더 가깝다고 할 수 있습니다.

</details>

----------------------------------------

<br />

----------------------------------------

### HTTP1.1 vs HTTP2.0

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

__HTTP(HyperText Transfer Protocol)__

WWW(World Wide Web)에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약이다.

__HTTP/1.1__

Connection당 하나의 요청을 처리 하도록 설계 되어 있다. 그래서 동시전송이 불가능하고 요청과 응답이 순차적으로 이루어 지게된다. 그렇다 보니 HTTP문서안에 포함된 다수의 리소스 (CSS, JS, Images)를 처리하려면 요청할 리소스 개수에 비례해서 Latency(대기 시간)는 길어지게 된다.

__HTTP/1.1 단점__
- HOL(Head Of Line) Blocking – 특정 응답의 지연
- RTT(Round Trip Time) 증가
- 무거운 Header 구조 (특히 Cookie)

__HTTP/2.0 장점__
- __Multiplexed Streams__
 	- 한 커넥션으로 동시에 여러개의 메세지를 주고 받을 있으며, 응답은 순서에 상관없이 stream으로 주고 받는다. HTTP/1.1의 Connection Keep-Alive, Pipelining의 개선이라 보면 된다.
- __Stream Prioritization__
 - 예를 들면 클라이언트가 요청한 HTML문서안에 CSS파일 1개와 Image파일 2개가 존재하고 이를 클라이언트가 각각 요청하고 난 후 Image파일보다 CSS파일의 수신이 늦어지는 경우 브라우저의 렌더링이 늦어지는 문제가 발생한다. HTTP/2의 경우 리소스간 의존관계(우선순위)를 설정하여 이런 문제를 해결하고 있다.
- __Server Push__
  - 서버는 클라이언트의 요청에 대해 요청하지도 않은 리소스를 마음대로 보내줄 수 도 있다.
  - 클라이언트가 HTML문서를 요청했고 해당 HTML에 여러개의 리소스(CSS, Image…) 가 포함되어 있는경우 HTTP/1.1에서 클라이언트는 요청한 HTML문서를 수신한 후 HTML문서를 해석하면서 필요한 리소스를 재 요청한다.
  - HTTP/2에선 Server Push를 이용하면 클라이언트가 요청하지도 않은 (HTML문서에 포함된 리소스) 리소스를 Push 해주는 방법으로 클라이언트의 요청을 최소화 해서 성능 향상을 이끌어 낸다. 
  - 이를 PUSH_PROMISE 라고 부르며 PUSH_PROMISE를 통해서 서버가 전송한 리소스에 대해선 클라이언트는 요청을 하지 않는다.

Source. [Link](https://www.popit.kr/%EB%82%98%EB%A7%8C-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%9E%88%EB%8D%98-http2/)

</details>

----------------------------------------

<br />

----------------------------------------

### URL 에 www.example.com 을 쳤을 때 일어나는 일들을 설명하세요.

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

- http://owlgwang.tistory.com/1 
- https://deveric.tistory.com/97
- [velog](https://velog.io/@jay/%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-velog.io%EB%A5%BC-%EC%9E%85%EB%A0%A5%ED%96%88%EC%9D%84%EB%95%8C-%EB%AC%B4%EC%8A%A8-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C-1-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)
- https://devjin-blog.com/what-happen-browser-search/

</details>

----------------------------------------

<br />

----------------------------------------

### 사용자가 웹브라우저를 통해 서버에 이미지를 요청해서 사용자에게 보여주기까지 과정을 설명하세요

<details>
   <summary> 참고 링크 보기 (👈 Click)</summary>
<br />

- 참고 [Link](https://krksap.tistory.com/1148?category=755546)

</details>

----------------------------------------

<br />

----------------------------------------

### HTTP와 HTTPS의 차이를 설명하세요.

<details>
   <summary> 참고 링크 보기 (👈 Click)</summary>
<br />

- 참고: [Link]( https://post.naver.com/viewer/postView.nhn?volumeNo=16561296&memberNo=1834)

</details>

----------------------------------------

<br />

----------------------------------------

### HTTP 프로토콜의 특징

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

- 비연결 지향(Connectionless) : 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊는다.
- 상태정보 유지 안 함(Stateless) : 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.

</details>

----------------------------------------

<br />

----------------------------------------

### 쿠키와 세션의 필요성

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

- 쿠키와 세션의 차이
  - 세션은 서버에 저장되고, 쿠키는 클라이언트에 저장된다고 하셨는데, 그럼 쿠키가 안되는 상황에서도 세션은 사용할 수 있나요?
- 참고 : https://github.com/WeareSoft/tech-interview/blob/master/contents/network.md

</details>

----------------------------------------

<br />

----------------------------------------
### 쿠키와 세션은 언제 사용하나요?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

쿠키와 세션은 HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용한다. 

   HTTP 프로토콜은 Connectionless, Stateless 하기 떄문에 클라이언트와 서버가 통신이 끝난 후 연결을 끊기고 데이터 상태 정보를 유지하지 않는다.
   
   하지만, 실제로는 데이터를 유지해야 하는 경우가 필요하다. 예를 들어, 정보를 유지하지 않는다면 매번 페이지를 이동할 때마다 로그인을 다시 하거나 상품을 선택했는데 구매 페이지에는 선택한 상품의 정보가 없거나 하는 등의 일이 발생할 수 있다. 
   
   -> 따라서 웹서버가 사용자(브라우저)의 상태 정보를 기억하기 위해 쿠키와 세션을 사용한다. 
   
   <br />
   
   <br />
   
   쿠키와 세션은 정보 유지를 하기 위해 사용되지만 차이점이 있다. 
   
- **세션 특징**
   
    - 클라이언트에서 관리하는 쿠키에 비해서 서버에 저장하는 세션은 보안이 좋다.
   
    - 서버 자원을 사용하기 때문에 사용자가 많을 경우 자원을 많이 소모할 수 있다.
   
    - 세션은 브라우저가 종료되면 자동으로 삭제된다. (만료기간 설정 가능)
   
    - 세션은 주로 보안이 중요한 로그인 정보를 유지하는데 사용한다.
   
<br />
   
- **쿠키 특징**
   
    - 쿠키는 세션에 비해 보안적인 측면에서 좋지 않다.
   
    - 서버에 저장되지 않고 브라우저(사용자의 컴퓨터)에 저장되기에 서버 자원의 낭비를 방지할 수 있으며 빠르다.
   
    - 브라우저가 종료되어도 `쿠키에 설정한` 만료 `시간`이 지나지 않으면 자동으로 삭제되지 않는다.
   
    - 쿠키는 보안이 중요하지 않고 브라우저가 종료되어도 유지할 수 있는 정보에 사용된다.
   
    - 활용 예: 주로 팝업창 "오늘 다시는 보지 않기" 로그인시 "id 기억하기" 체크, 비로그인시 장바구니 넣기
   
   <br />    

### **심화 질문**
   
Q. 만약 로드 밸런싱을 사용하고 있는 웹서버의 경우에는 세션을 어떻게 관리할까요?
(사용자가 어떤 웹서버에 붙느냐에 따라 세션 정보를 다시 저장해야 할까요?)   

**1) 스티키 세션** (Sticky Session)

- 로드 밸런서가 쿠키가 없는 요청이라면 쿠키 값을 등록하고 웹서버를 지정한다.
- 쿠키가 있다면 해당 요청이 쿠키에 지정된 서버로 보낸다.

**단점**

- 로드밸런싱이 잘 동작하지 않을 수 있다.
- 고정된 세션을 사용하기에 특정 서버만 과부하가 올 수 있다.
- 특정 서버 Fail시 해당 서버에 붙어 있는 세션들이 소실될 수 있다.

<br />
   
**2) 세션 클러스터링** (Session Clustering)

- 클러스터링은 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하도록 만드는 것이다.
- 즉, 각 서버의 세션에 모든 세션 저장소의 세션 객체를 복제한다.

**단점**

- 매번 세션 객체를 복제하는데 오버헤드가 발생한다.

<br />   
   
**3) 세션 스토리지 분리** (별도의 세션 저장소 사용 - Redis, MongoDB, DynamoDB..)

- 별도의 세션 저장소를 사용한다. 세션 저장소가 하나이기에 세션을 서버간 복제를 할 필요가 없다.
- 서버가 아무리 늘어난다 해도 세션 스토리지에 대한 정보만 각각의 서버에 입력해주면 세션을 공유할 수 있다. 또한, 트래픽이 몰리는 현상을 고려하지 않아도 된다.
- 하나의 서버가 장애가 발생해도 별도의 세션 저장소가 존재하기 때문에 서비스를 계속 제공할 수 있다. (가용성 확보)

cf) [https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html)

cf) [https://hyuntaeknote.tistory.com/6](https://hyuntaeknote.tistory.com/6)
   
</details>

----------------------------------------

<br />

----------------------------------------

### Session 인증 방식과 Token 인증 방식의 차이점

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />

세션, 토큰에 들어가기 앞서 인증, 인가를 구별하자!

누가, 언제, 어떻게 쓰고 있는가를 파악하기 위해 사용한다. 

<br />
   
**인증(Authentication)이란?**

유저가 누구인지 확인하는 절차, 회원가입하고 로그인 하는 것
   
<br />

**인가(Authorization)란?**

유저에 대한 권한을 허락하는 것
   
<br />

웹 서버는 Stateless 프로토콜인 HTTP를 사용하기 때문에 웹사이트에서 인증을 관리하기 위한 방안이 필요하다. 크게 Session 기반 인증, Token 기반 인증이 있다. 

### 세션 기반 인증

1) 유저가 로그인을 한다.
   
2) 로그인이 성공하면 **서버는 메모리나 DB에 세션을 저장**하고, 서버가 **클라이언트**(웹 브라우저)에 세션 ID를 전송하여 **쿠키(Cookie)에** 저장한다. 
   
3) 브라우저는 로그인이 되었는지 확인하기 위해 매 요청시 Request에 Session ID를 쿠키에 담아 전송한다
   
4) 서버는 Session ID가 일치하는지 확인한 후 일치하면 요청에 응답한다.

### 세션 기반 인증 장점

- 서버 쪽에서 사용자의 로그인 상태에 확인이 쉽고 분명하다.
- 서버 쪽에서 세션 정보를 관리하기 때문에 클라이언트의 변조에 영향 받기 어렵고 데이터의 손상 우려가 없어 상대적으로 안전하다.
- 토큰 방식에 Signature 등 부가적인 정보가 없기에 Server-Clinet간 주로 받는 데이터가 적다.

### 세션 기반 인증 단점

- 대규모 서비스로의 스케일업을 위해서는 메모리에 저장되는 세션 정보로 인한 메모리 성능 부하가 있을 수 있다. Redis나 Memcached 등의 메모리 관리 시스템이 필요하다.
- 메모리에 저장된 세션 정보는 휘발성이기에 서버 재부팅시 사라질 수 있으며 많은 정보를 저장하는데 한계가 있다. 그렇다고 하드디스크나 DB에 저장하기에는 작업이 느리고 무겁다
- 쿠키는 단일 도메인, 서브 도메인에서만 작동하기 때문에 여러 도메인에서 사용할 경우 관리를 해줘야 한다.
- 세션 정보를 메모리에 저장하기에 부담이 있다.

<br />
   
### 토큰 기반 인증 (JWT - JSON Web Token)

토큰 기반 인증은 인증받은 사용자들에게 토큰을 발급하고, 서버에 요청을 할 때 헤더에 토큰을 함께 보내 유효성을 검사하는 방식이다. 

1) 사용자가 로그인을 하면 서버측에서 계정 정보를 검증한다.

2) 검증이 완료되면, 서버측에서 클라이언트에게 signed token을 발급하고 클라이언트는 이를 저장한다. (signed token은 정상적으로 발급된 토큰임을 증명하는 signature가 있다는 것)

3) 클라이언트는 서버에 요청 시 저장된 Token을 Header에 포함시켜 보낸다.
4) 서버는 Token 정보를 검증하고 해당 유저에 권한을 인가한다. 

### 토큰 기반 인증 장점

- 클라이언트가 토큰 정보를 갖고 있기 때문에 서버를 스케일업하는데 부담이 적다.
- 클라이언트 세션 관리에 대한 서버의 메모리 부담을 줄일 수 있다.
- 다양한 도메인에 대응하는데 부담이 적다.

### 토큰 기반 인증 단점

- 토큰 정보가 탈취될 수도 있어도 무효화할 수 없다. 보안에 취약하다.
- 토큰에 Signature 등의 부가적인 정보가 담겨 있기에 서버-클라이언트 간 주고 받는 데이터가 세션 기반의 인증보다 많다.
- 토큰 인증을 위해 Database에서 매번 조회해야 하므로 DB 성능 부하가 있을 수 있다.

 <br />
   
https://sherryhsu.medium.com/session-vs-token-based-authentication-11a6c5ac45e4 참고

### JWT

[https://mangkyu.tistory.com/56](https://mangkyu.tistory.com/56) 참고
   
</details>

----------------------------------------

<br />

----------------------------------------

### HTTP2의 특징을 설명하세요.

> 답안 준비중입니다.

----------------------------------------

<br />

----------------------------------------

### HTTP 응답코드에 대해서 설명하세요.

> 답안 준비중입니다.

----------------------------------------

<br />

----------------------------------------

### OSI 7 Layer에 대해서 설명하세요. 

> 답안 준비중입니다.

----------------------------------------

<br />

----------------------------------------

### DNS에 대해서 설명하세요. 

> 답안 준비중입니다.

----------------------------------------

<br />

----------------------------------------

### Web으로 Server Push를 구현할 때 제약사항 등을 설명하세요.

> 답안 준비중입니다.

----------------------------------------

<br />

----------------------------------------

### 3 way hand shake에 대해서 설명하세요.

> 답안 준비중입니다.

----------------------------------------

<br />

----------------------------------------

### 4 way hand shake에 대해서 설명하세요.

> 답안 준비중입니다.

----------------------------------------

<br />

----------------------------------------

### 흐름제어, 혼잡제어방식에 대해서 설명하세요.

> 답안 준비중입니다.

------------------------------------------

<br />

# 🔥 Challenge

<br />

----------------------------------------

### 웹 사이트를 제작했는데 고해상도 이미지를 많이 사용하여 페이지 로딩 속도가 느립니다. 최적화 하는 방법에 대해서 모두 설명하세요.

> 답안 준비중입니다.

----------------------------------------

<br />

----------------------------------------

### 브라운이 새로운 검색 엔진을 개발하려고 합니다. 어떻게 설계 및 개발 것인지 아는 지식을 모두 동원하여 설명하세요.

> 답안 준비중입니다.

----------------------------------------


<br />
<br />
<div align=center>
  <hr />
    <h3> 용감한 친구들 with 남송리 삼번지 </h3>
  <hr />
</div>
   
